import struct
import argparse
import hashlib
import base64
import subprocess
import io
import os
from typing import Tuple

parser = argparse.ArgumentParser()
parser.add_argument('path')
parser.add_argument('-e', '--entrypoint')
parser.add_argument('-o', '--output', default='a.out')


class ELFHeader:
    size = 52

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.e_ident,
            self.e_type, self.e_machine, self.e_version,
            self.e_entry, self.e_phoff, self.e_shoff,
            self.e_flags,
            self.e_ehsize,
            self.e_phentsize, self.e_phnum,
            self.e_shentsize, self.e_shnum,
            self.e_shstrndx,
        ) = struct.unpack('16sHHIIIIIHHHHHH', content[offset:offset + self.size])


class ELFHeader64:
    size = 64

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.e_ident,
            self.e_type, self.e_machine, self.e_version,
            self.e_entry, self.e_phoff, self.e_shoff,
            self.e_flags,
            self.e_ehsize,
            self.e_phentsize, self.e_phnum,
            self.e_shentsize, self.e_shnum,
            self.e_shstrndx,
        ) = struct.unpack('16sHHIQQQIHHHHHH', content[offset:offset + self.size])


class SymTabEntry:
    size = 16

    NO_TYPE = 0
    OBJECT = 1
    FUNC = 2
    SECTION = 3
    FILE = 4

    LOCAL = 0
    GLOBAL = 1

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.st_name, self.st_value, self.st_size,
            st_info, self.st_other, self.st_shndx,
        ) = struct.unpack('IIIBBH', content[offset:offset + self.size])
        self.st_bind = st_info >> 4
        self.st_type = st_info & 0xf

    def is_global_func(self) -> bool:
        return self.st_type == self.FUNC and self.st_bind == self.GLOBAL


class SymTabEntry64(SymTabEntry):
    size = 24

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.st_name, st_info, self.st_other,
            self.st_shndx, self.st_value, self.st_size,
        ) = struct.unpack('IBBHQQ', content[offset:offset + self.size])
        self.st_bind = st_info >> 4
        self.st_type = st_info & 0xf


class SectionHeader:
    size = 40

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.sh_name, self.sh_type, self.sh_flags,
            self.sh_addr, self.sh_offset, self.sh_size,
            self.sh_link, self.sh_info, self.sh_addralign, self.sh_entsize,
        ) = struct.unpack('IIIIIIIIII', content[offset:offset + self.size])

    def get_bound(self) -> Tuple[int, int]:
        return self.sh_offset, self.sh_offset + self.sh_size


class SectionHeader64(SectionHeader):
    size = 64

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.sh_name, self.sh_type, self.sh_flags,
            self.sh_addr, self.sh_offset, self.sh_size,
            self.sh_link, self.sh_info, self.sh_addralign, self.sh_entsize,
        ) = struct.unpack('IIQQQQIIQQ', content[offset:offset + self.size])


class ProgramHeader64:
    size = 56

    def __init__(self, content: bytes, offset: int = 0):
        (
            self.p_type, self.p_flags, self.p_offset,
            self.p_vaddr, self.p_paddr, self.p_filesz,
            self.p_memsz, self.p_align,
        ) = struct.unpack('IIQQQQQQ', content[offset:offset + self.size])


class StrTab:

    def __init__(self, content: bytes):
        self._content = content

    def __getitem__(self, start: int) -> str:
        end = self._content.find(b'\0', start)
        return self._content[start:end].decode('utf-8')


class RelEntry:
    size = 8

    def __init__(self, content: bytes, offset: int = 0):
        self.r_offset, r_info = struct.unpack('II', content[offset:offset + self.size])
        self.r_sym = r_info >> 8
        self.r_type = r_info & 0xff


ASM_FORMAT = '''# Auto-generated by Uni-ld.
# Do not modify by hand.
    .local  main_stack
    .comm   main_stack, 16, 8
    .text
    .global main
main:
    la  a0, main_stack
    sd  sp, 0(a0)
    sd  ra, 8(a0)
    la  a0, __entrypoint
    add x0, x0, x1      # enter unicore
    .word   0x11ffc12a  # jump.l a0
    .word   0x1a028000  # mov a0, r0
    add x0, x0, x2      # exit unicore
    la  sp, main_stack
    ld  ra, 8(sp)
    ld  sp, 0(sp)
    ret
    .align 4
    .global __unicore_text
__unicore_text:
{text}
    .data
    .align 4
    .global __unicore_data
__unicore_data:
{data}
{bss}'''

if __name__ == '__main__':
    args = parser.parse_args()
    with open(args.path, 'rb') as f:
        content = f.read()

    # parse header
    elf_header = ELFHeader(content)

    section_headers = []
    for i in range(elf_header.e_shnum):
        offset = elf_header.e_shoff + elf_header.e_shentsize * i
        section_headers.append(SectionHeader(content, offset))

    begin, end = section_headers[elf_header.e_shstrndx].get_bound()
    shstrtab = StrTab(content[begin:end])

    # parse sections
    text, data, bss = [], [], ''
    symtab = []
    rel_text = []

    for h in section_headers:
        name = shstrtab[h.sh_name]
        if name in {'.text', '.data'}:
            begin, end = h.get_bound()
            for i in range(begin, end, 4):
                s = '    .word 0x%08x' % struct.unpack('I', content[i:i + 4])
                if name == '.text':
                    text.append(s)
                else:
                    data.append(s)
        elif name == '.bss':
            bss = ('    .local  __unicore_bss\n'
                   '    .comm   __unicore_bss, %d, %d\n') % (h.sh_size, h.sh_addralign)
        elif name == '.symtab':
            begin, end = h.get_bound()
            for i in range(begin, end, SymTabEntry.size):
                symtab.append(SymTabEntry(content, i))
        elif name == '.strtab':
            begin, end = h.get_bound()
            strtab = StrTab(content[begin:end])
        elif name.startswith('.rel'):
            assert name == '.rel.text'
            begin, end = h.get_bound()
            for i in range(begin, end, RelEntry.size):
                rel_text.append(RelEntry(content, i))

    # decide entrypoint
    entrypoints = [e for e in symtab if e.is_global_func()]
    if args.entrypoint:
        entrypoint = None
        for e in entrypoints:
            if strtab[e.st_name] == args.entrypoint and e.is_global_func():
                entrypoint = e
                break
        if entrypoint is None:
            raise Exception("Cannot find entrypoint: '%s'" % args.entrypoint)
    elif len(entrypoints) == 1:
        entrypoint = entrypoints[0]
    else:
        raise Exception('Cannot decide entrypoint automatically\n')
    assert shstrtab[section_headers[entrypoint.st_shndx].sh_name] == '.text'

    # format assembly
    text.insert(entrypoint.st_value // 4, '__entrypoint:')
    text = '\n'.join(text)
    data = '\n'.join(data)
    asm = ASM_FORMAT.format(text=text, data=data, bss=bss)
    uidb = hashlib.sha256(asm.encode('utf-8')).digest()[:6]
    uids = base64.b64encode(uidb).decode('utf-8').replace('+', '-').replace('/', '_')
    asm_path = uids + '.s'
    with open(asm_path, 'w') as f:
        f.write(asm)

    # compile
    out_path = uids + '.out'
    cmd = ['riscv64-unknown-elf-gcc',
           '-march=rv64g', '-mabi=lp64d', '-mcmodel=medany',
           '-I.', '-O3',
           '-nostdlib', '-nostartfiles', '-Tlink.ld', '-static',
           '-o', out_path, asm_path, 'lib/crt.S', 'lib/syslib.c']
    p = subprocess.Popen(cmd)
    if p.wait():
        exit(p.returncode)

    with open(out_path, 'rb') as f:
        content = f.read()

    # parse header
    elf_header = ELFHeader64(content)

    section_headers_old = section_headers
    section_headers = []
    for i in range(elf_header.e_shnum):
        offset = elf_header.e_shoff + elf_header.e_shentsize * i
        section_headers.append(SectionHeader64(content, offset))

    program_headers = []
    for i in range(elf_header.e_phnum):
        offset = elf_header.e_phoff + elf_header.e_phentsize * i
        program_headers.append(ProgramHeader64(content, offset))

    begin, end = section_headers[elf_header.e_shstrndx].get_bound()
    shstrtab_old = shstrtab
    shstrtab = StrTab(content[begin:end])

    # parse sections
    symtab_old = symtab
    symtab = []
    for h in section_headers:
        name = shstrtab[h.sh_name]
        if name == '.text':
            text = h
        elif name == '.data':
            data = h
        elif name == '.bss':
            bss = h
        elif name == '.symtab':
            begin, end = h.get_bound()
            for i in range(begin, end, SymTabEntry64.size):
                symtab.append(SymTabEntry64(content, i))
        elif name == '.strtab':
            begin, end = h.get_bound()
            strtab = StrTab(content[begin:end])

    for e in symtab:
        name = strtab[e.st_name]
        if name == '__unicore_text':
            text_uc = e.st_value
        elif name == '__unicore_data':
            data_uc = e.st_value
        elif name == '__unicore_bss':
            bss_uc = e.st_value

    # relocate
    out = io.BytesIO(content)
    for e in rel_text:
        if e.r_type == 1:  # func call
            continue
        offset = e.r_offset + text.sh_offset + text_uc - text.sh_addr
        shndx = symtab_old[e.r_sym].st_shndx
        sh_name = shstrtab_old[section_headers_old[shndx].sh_name]
        v, = struct.unpack('I', content[offset:offset + 4])
        v0 = v
        if sh_name == '.text':
            v += text_uc
        elif sh_name == '.data':
            v += data_uc
        elif sh_name == '.bss':
            v += bss_uc
        else:
            raise Exception("Cannot handle section '%s'" % sh_name)
        out.seek(offset)
        out.write(struct.pack('I', v))

    out.seek(0)
    with open(args.output, 'wb') as f:
        f.write(out.read())
    os.chmod(args.output, 0o755)
    os.remove(asm_path)
    os.remove(out_path)
